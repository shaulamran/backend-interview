---
id: cy4xx
name: How Expression extraction regex  Works
file_version: 1.0.2
app_version: 0.9.1-5
file_blobs:
  src/expression-parser/expressionToTree.ts: c65b5c025c8b85ee41869e2eed4ee1cde6cdf982
---

This function is the entry point to the parser logic. It receives an expression as a string as it was received from the web client and starts a recursive parsing logic using a binary tree.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ src/expression-parser/expressionToTree.ts
```typescript
â¬œ 1      import {Equal, GreaterThan, LowerThan, AndOperator, OrOperator, NotOperator, Expression} from './expressionClasses';
â¬œ 2      
ðŸŸ© 3      function expressionToTree(expression: string, obj: Record<string, string>) : Expression {
â¬œ 4        // Removing whitespaces and quotation marks
â¬œ 5        expression = expression
â¬œ 6          .replace(/\s/g, '')
```

<br/>

There are two kinds of operators: Atomic and Complex.  
Atomic operator means that it holds two an expression that can be calculated.

Complex operator means that it holds two more expressions in it and they can be either complex themselves or atomic, hence the recursion in the function.

Each operator has a parsing function for a single atomic expression or a complex one.

There is one special operator called `NOT` which isn't atomic but also doesn't have two expressions in it, but one instead it has its own special parsing function called `parseNotExpression`.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ src/expression-parser/expressionToTree.ts
```typescript
â¬œ 13       return parsingFunc(expression, className, obj);
â¬œ 14     }
â¬œ 15     
ðŸŸ© 16     const operatorToClassMap = {
â¬œ 17       EQUAL: { className: Equal, parsingFunc: parseAtomicExpression },
â¬œ 18       GREATER_THAN: { className: GreaterThan, parsingFunc: parseAtomicExpression },
â¬œ 19       LOWER_THAN: { className: LowerThan, parsingFunc: parseAtomicExpression },
```

<br/>

The `operandsRegex`[<sup id="Z2erkm9">â†“</sup>](#f-Z2erkm9) assumes that the expression is an Atomic one (not a Complex one) and contains an operator and two operands. For example: `EQUALS('id', 1000)`. The regex captures the characters between the opening parentheses and the ONLY comma into `operand1`[<sup id="2mICmk">â†“</sup>](#f-2mICmk) group and the characters after the comma and the closing parentheses into `operand2`[<sup id="1iFN5Y">â†“</sup>](#f-1iFN5Y) group.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ src/expression-parser/expressionToTree.ts
```typescript
â¬œ 54       return expressionTree;
â¬œ 55     }
â¬œ 56     
ðŸŸ© 57     function extractOperands(expression: string) {
ðŸŸ© 58       var operandsRegex = new RegExp(/([^(]+),([^\)]+)\)/gim);
ðŸŸ© 59       var match = operandsRegex.exec(expression);
ðŸŸ© 60       const operand1 = match[1];
ðŸŸ© 61       const operand2 = match[2];
ðŸŸ© 62       return { operand1, operand2 };
ðŸŸ© 63     }
â¬œ 64     
â¬œ 65     function extractTwoSubExpressions(expression: string) {
â¬œ 66       let parenthesisCounter = 0;
```

<br/>

<!-- THIS IS AN AUTOGENERATED SECTION. DO NOT EDIT THIS SECTION DIRECTLY -->
### Swimm Note

<span id="f-2mICmk">operand1</span>[^](#2mICmk) - "src/expression-parser/expressionToTree.ts" L60
```typescript
  const operand1 = match[1];
```

<span id="f-1iFN5Y">operand2</span>[^](#1iFN5Y) - "src/expression-parser/expressionToTree.ts" L61
```typescript
  const operand2 = match[2];
```

<span id="f-Z2erkm9">operandsRegex</span>[^](#Z2erkm9) - "src/expression-parser/expressionToTree.ts" L58
```typescript
  var operandsRegex = new RegExp(/([^(]+),([^\)]+)\)/gim);
```

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBYmFja2VuZC1pbnRlcnZpZXclM0ElM0FzaGF1bGFtcmFu/docs/cy4xx).